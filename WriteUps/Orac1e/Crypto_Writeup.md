# Crypto

这是一篇Crypto方向赛题的writeup，写的非常粗糙，还望各位师傅见谅。

## baby_e

```python
from Crypto.Util.number import getPrime,bytes_to_long

p,q = getPrime(2048),getPrime(2048)
e = 7
n = p*q
m = bytes_to_long(open('flag.txt','rb').read().strip())
c = pow(m,e,n)
print("c = ",c)
print("n = ",n)

c =  147693154873835354725007152781732424355869776162377337823960431913672366269917723916891506269449726723757821517328874729037838600793748824028829185409932536014732765063216715033843955453706710187792772702199448156372644163429786386035008302836467605094954587157232829525150652611067567669525072625329634860065850520051628272535479197120008981979404760445193750864902244921407742155742716289495581989134730376783828846663464819337418977287363028738701414486788851136608957124505485242331701209645216580641917007780811842757125048746184068597664780265422321550909392419865169775282217442331295071069272774722564587602419768461231775480847018941840911357926330143045826277813722919121117172763493242590521245640828462665947672485094793188432098216701511715232654611338293295459889814699850788048985878279440740712956248569068077253790198036918598519191892836075254345518967666166925163908185663991353344555402397055977817370082929420443034626201745027965444069777059760865359310439815816749939498993014457995041394803598825093836045546578310632172636478575946653375857640993393714607308326474003446154152048840071034349831168612740218034679021240949747357214453636633636662650940968576792518622437627529244515229173
n =  553409369582823237678532685244026647155180191225879439432235077135813123637186465008813830373646133388592395760175777499266561095087891764348044063111935877931069321764391883899483374576303169645488542398590564148654412004383012178107972880058460460806768779452529433458826925606225797078653905380530651390617109384086518728626571028089036812787671647095695947167204428442727185744172445701874820612799168887428075695751162763647868386879374037826876671079326544820609721731078985096813307183878793033824330869698508952853770794414757655681370862323768018291030331209143189638496644361618184164228294031490537429556439588954274708598530042700988138862000054458742762198052079867259365645914383561162796796952346445529346145323567650621600171442575319262718389389870407629339714751583360252884338116164466349449862781112019462555743429653595045695696967783338371470032332852204294900011651434678829104876529439166176589508898757122660322523937330848536715937381297551894198974459004139082562228022412335520195652419375915216074658463954339332593244483927157329404652516225481116614815221154229491846087288087715884363786672244655901308480290011237244562251084095684531716327141154558809471185132979704992609461470501119328696999713829  
```

注意到模数$N$十分巨大(4096bits),$e$又十分小($e=7$)。我们可以尝试一下低加密指数攻击

```python
from Crypto import long_to_bytes
from gmpy2 import iroot

a = iroot(c, e)[0]
assert pow(a, e, n) == c

print(long_to_bytes(a))
```

flag为moectf{SMaLL_3xPon3nt_Mak3_rSa_w3ak!_!lP0iYlJf!M3rux9G9Vf!JoxiMl903lllA}

## bad_E

题目源码为：

```python
from Crypto.Util.number import *
p = getPrime(512)
q = getPrime(512)
e = 65537

print(p) # 6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571
print(q) # 11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819

with open("flag.txt","r") as fs:
    flag = fs.read().strip()

m = bytes_to_long(flag.encode())
c = pow(m,e,p*q)
print(c) # 63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805 
```

经过计算很容易发现$e$与$\phi(p*q)$不互素，更进一步地$gcd(q-1, e) = 1$
，我们可以尝试先计算$m\bmod q$的结果。

幸运的是$m < q$,我们便得到了明文：moectf{N0w_Y0U_hAve_kN0w_h0w_rsA_w0rks!_f!lP0iYlJf!M3ru}

## factor_signin

```python
from Crypto.Util.number import getPrime
from math import prod

with open("flag.txt","rb") as f:
    flag = f.read().strip()
assert len(flag) == 72

m1 = int.from_bytes(flag[:36],"big")
m2 = int.from_bytes(flag[36:],"big")

e = 65537

p,q = getPrime(2048),getPrime(2048)
n1 = p*q
c1 = pow(m1,e,n1)
print("c1 = ",c1)
print("n1 = ",n1)

primes = [getPrime(64) for _ in range(32)]
n2 = prod(primes)
c2 = pow(m2,e,n2)
print("c2 = ",c2)
print("n2 = ",n2)

# c1 =  10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125
# n1 =  343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641
# c2 =  4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295
# n2 =  8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737
```

我们可以尝试使用大整数在线分解网站(factordb)，看看有没有收录$n_1$的分解(可能是出题人自己上传的分解结果)，$n_2$具有多个较小的素因子(64bits)，我们可以尝试椭圆曲线分解算法(ECM)来分解$n_2$。

解题脚本如下：

```python
from sage.all import *
from Crypto.Util.number import *

e = 65537
c1 = 10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125
n1 = 343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641
c2 = 4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295
n2 = 8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737

p1 = 18055722101348711626577381571859114850735298658417345663254295930584841136416234624852520581982069555948490061840244710773146585295336094872892685938420880462305333393436098181186277450475949236132458958671804132443554885896037342335902958516394876382378829317303693655605215373555988755516058130500801822723195474873517960624159417903134580987202400855946137101429970119186394052011747475879598126195607938106163892658285305921071673588966184054026228745012993740035399652049777986535759039077634555909031397541116025395236871778797949216479130412500655359057128438928721459688727543057760739527720641179290282309741

q1 = n1 // p1

phi1 = (n1 - p1 - q1 + 1)
d1 = inverse(e, phi1)
m1 = long_to_bytes(pow(c1, d1, n1))


a = [9949603102225364603,10049235158029375571, 10547615587767500213, 10596280721192026229, 10864078180916418691, 11092420583960163379, 11853704782834170959, 12034779627328165471, 12404642343676224637, 12448177342966243757, 13062839684118954553, 13645878578452317313, 14397830993057803133, 14619040595108594017, 14678737767649343977, 14745811312384518031, 14813953870710226847, 15175734709842430433, 15211380502610462057, 15332916111580607077, 15751974537676958401, 16123604149048919099, 16408421615173973083, 16870346804576162551, 17093292308638969889, 17265001711647542137, 17289161209347211817, 17543713628803023199, 17673334943789572513, 18106525049998616747, 18345408081492711641, 18390046459144888243]

phi2 = 1
for item in a:
    phi2 *= (item - 1)

d2 = inverse(e, phi2)
m2 = long_to_bytes(pow(c2, d2, n2))
print(m1 + m2)
```

## Feistel

本题考察分组密码设计常用的Feistel网络。

容易发现对于题目所描述的加密算法，解密算法与之完全相同。(可以试着自己在纸上推演一遍）

于是，我们便可以很容易就拿到了Flag。
解题脚本如下：

```python
from Crypto.Util.number import *

def f(m, key):
    m = m ^ (m >> 4)
    m = m ^ (m << 5)
    m = m ^ (m >> 8)
    m ^= key
    m = (m * 1145 + 14) % 2**64
    m = (m * 1919 + 810) % 2**64
    m = (m * key) % 2**64
    return m


def enc(m, key, round):
    key = bytes_to_long(key)
    left = bytes_to_long(m[:8])
    right = bytes_to_long(m[8:])
    for i in range(round):
        left, right = right, f(right, key) ^ left
    left, right = right, left
    return long_to_bytes(left).rjust(8, b"\x00") + long_to_bytes(right).rjust(8, b"\x00")


def padding(m):
    mlen = len(m)
    pad = 16 - mlen % 16
    return m + pad * bytes([pad])
# 填充算法

def ecb_enc(m, key):
    m = padding(m)
    mlen = len(m)
    c = b""
    for i in range(mlen // 16):
        c += enc(m[i * 16 : i * 16 + 16], key, round)
    return c
# 使用了ECB工作模式
# print(ecb_enc(flag, b"wulidego"))
key = b"wulidego"
round = 2
c =  b'\x0b\xa7\xc6J\xf6\x80T\xc6\xfbq\xaa\xd8\xcc\x95\xad[\x1e\'W5\xce\x92Y\xd3\xa0\x1fL\xe8\xe1"^\xad'
print(len(c))
C = []
for i in range(len(c)//16):
    C.append(c[i * 16 : i * 16 + 16])

# dec()和enc()完全相同    
def dec(m, key, round):
    key = bytes_to_long(key)
    left = bytes_to_long(m[:8])
    right = bytes_to_long(m[8:])
    for i in range(round):
        left, right = right, f(right, key) ^ left
    left, right = right, left
    return long_to_bytes(left).rjust(8, b"\x00") + long_to_bytes(right).rjust(8, b"\x00")        
print((dec(c[:16], key, 2))+(dec(c[16:], key, 2)))
```

## |p-q|

```python
with open("flag.txt","rb") as fs:
    flag = fs.read().strip()
assert len(flag) == 72

m = int.from_bytes(flag,"big")

from Crypto.Util.number import getPrime, isPrime

def next_prime(p):
    while True:
        p += 2
        if isPrime(p):
            return p

p = getPrime(2048)
q = next_prime(p)
n = p * q
e = 65537
c = pow(m,e,n)
print("n =",n)
print("c =",c)

# n = 329960318345010350458589325571454799968957932130539403944044204698872359769449414256378111233592533561892402020955736786563103586897940757198920737583107357264433730515123570697570757034221232010688796344257587359198400915567115397034901247038275403825404094129637119512164953012131445747740645183682571690806238508035172474685818036517880994658466362305677430221344381425792427288500814551334928982040579744048907401043058567486871621293983772331951723963911377839286050368715384227640638031857101612517441295926821712605955984000617738833973829140899288164786111118033301974794123637285172303688427806450817155786233788027512244397952849209700013205803489334055814513866650854230478124920442832221946442593769555237909177172933634236392800414176981780444770542047378630756636857018730168151824307814244094763132088236333995807013617801783919113541391133267230410179444855465611792191833319172887852945902960736744468250550722314565805440432977225703650102517531531476188269635151281661081058374242768608270563131619806585194608795817118466680430500830137335634289617464844004904410907221482919453859885955054140320857757297655475489972268282336250384384926216818756762307686391740965586168590784252524275489515352125321398406426217
# c = 307746143297103281117512771170735061509547958991947416701685589829711285274762039205145422734327595082350457374530975854337055433998982493020603245187129916580627539476324521854057990929173492940833073106540441902619425074887573232779899379436737429823569006431370954961865581168635086246592539153824456681688944066925973182272443586463636373955966146029489121226571408532284480270826510961605206483011204059402338926815599691009406841471142048842308786000059979977645988396524814553253493672729395573658564825709547262230219183672493306100392069182994445509803952976016630731417479238769736432223194249245020320183199001774879893442186017555682902409661647546547835345461056900610391514595370600575845979413984555709077635397717741521573798309855584473259503981955303774208127361309229536010653615696850725905168242705387575720694946072789441481191449772933265705810128547553027708513478130258801233619669699177901566688737559102165508239876805822898509541232565766265491283807922473440397456701500524925191214292669986798631732639221198138026031561329502985577205314190565609214349344303324429408234237832110076900414483795318189628198913032900272406887003325858236057373096880675754802725017537119549989304878960436575670784578550
```

分析题目，我们发现模数$N$的生成有点问题,$p,q$是两个相邻的素数。于是我们可以采用$Fermat$分解法来解这道题。

解题脚本如下：

```python
from Crypto.Util.number import *
from math import *
from gmpy2 import *


n = 329960318345010350458589325571454799968957932130539403944044204698872359769449414256378111233592533561892402020955736786563103586897940757198920737583107357264433730515123570697570757034221232010688796344257587359198400915567115397034901247038275403825404094129637119512164953012131445747740645183682571690806238508035172474685818036517880994658466362305677430221344381425792427288500814551334928982040579744048907401043058567486871621293983772331951723963911377839286050368715384227640638031857101612517441295926821712605955984000617738833973829140899288164786111118033301974794123637285172303688427806450817155786233788027512244397952849209700013205803489334055814513866650854230478124920442832221946442593769555237909177172933634236392800414176981780444770542047378630756636857018730168151824307814244094763132088236333995807013617801783919113541391133267230410179444855465611792191833319172887852945902960736744468250550722314565805440432977225703650102517531531476188269635151281661081058374242768608270563131619806585194608795817118466680430500830137335634289617464844004904410907221482919453859885955054140320857757297655475489972268282336250384384926216818756762307686391740965586168590784252524275489515352125321398406426217
a = gmpy2.iroot(n, 2)[0]
for i in range(a - 100000, n+100000):
    if GCD(i, n)>1:
        if isPrime(i):
            p = i
            q = n//i
            print(p)
            print(q)
            break
        else:
            continue
    else:
        continue
    
p = 18164809890142267890219276206773099235072154806950582020347085518282960761937147879570277730919110196557742226232054602784278585009762036923951358612733074768279344311938292845187804144458991947979616574535662033512236959010688698879953460760771547964758688700129994322153904156260452550830932232536673055480604083903327472696393017478985867846428177588049472509968031143243583420309569129756696755744088888618703553769561648077215188783123207031628505020478500655602448720006243614258852026797076054766680755124052134730998085155245587457870148748357237005392662882609410088994421984160941612734270140092780661012811    
q = 18164809890142267890219276206773099235072154806950582020347085518282960761937147879570277730919110196557742226232054602784278585009762036923951358612733074768279344311938292845187804144458991947979616574535662033512236959010688698879953460760771547964758688700129994322153904156260452550830932232536673055480604083903327472696393017478985867846428177588049472509968031143243583420309569129756696755744088888618703553769561648077215188783123207031628505020478500655602448720006243614258852026797076054766680755124052134730998085155245587457870148748357237005392662882609410088994421984160941612734270140092780661013147
phi = (p-1)*(q-1)
e = 65537
d = inverse(e, phi)

c = 307746143297103281117512771170735061509547958991947416701685589829711285274762039205145422734327595082350457374530975854337055433998982493020603245187129916580627539476324521854057990929173492940833073106540441902619425074887573232779899379436737429823569006431370954961865581168635086246592539153824456681688944066925973182272443586463636373955966146029489121226571408532284480270826510961605206483011204059402338926815599691009406841471142048842308786000059979977645988396524814553253493672729395573658564825709547262230219183672493306100392069182994445509803952976016630731417479238769736432223194249245020320183199001774879893442186017555682902409661647546547835345461056900610391514595370600575845979413984555709077635397717741521573798309855584473259503981955303774208127361309229536010653615696850725905168242705387575720694946072789441481191449772933265705810128547553027708513478130258801233619669699177901566688737559102165508239876805822898509541232565766265491283807922473440397456701500524925191214292669986798631732639221198138026031561329502985577205314190565609214349344303324429408234237832110076900414483795318189628198913032900272406887003325858236057373096880675754802725017537119549989304878960436575670784578550
m = gmpy2.powmod(c, d, n)
print(long_to_bytes(m))   
```

flag为moectf{it_iS_vUlnErablE_iF_p_iS_aboUt_thE_SaME_SiZE_aS_Q_MVoAYArrlG3uco}

## rsa_signin

先看题目代码

```python
with open("flag.txt","rb") as f:
    flag = f.read().strip()

m = int.from_bytes(flag, "big")
e = 65537

from Crypto.Util.number import getPrime

for x in range(10):
    p = getPrime(1024)
    q = getPrime(1024)
    n = p * q
    c = pow(m, e, n)

    print("n =", n)
    print("c =", c)

'''
n = 17524722204224696445172535263975543817720644608816706978363749891469511686943372362091928951563219068859089058278944528021615923888948698587206920445508493551162845371086030869059282352535451058203615402089133135136481314666971507135484450966505425514285114192275051972496161810571035753943880190780759479521486741046704043699838021850105638224212696697865987677760179564370167062037563913329993433080123575434871852732981112883423565015771421868680113407260917902892944119552200927337996135278491046562185003012971570532979090484837684759828977460570826320870379601193678304983534424368152743368343335213808684523217
c = 6870605439714128574950893771863182370595667973241984289208050776870220326525943524507319708560433091378319367164606150977103661770065561661544375425887970907060665421562712515902428061727268441585629591525591001533188276465911918724808701356962871139957343861919730086334623932624184172272488406793955068827527130338853980609365042071290967556159598511667974987218999253443575482949258292953639729393456515185185102248985930422080581185292420347510600574229080211050520146551505605537486989306457793451086767402197128573781597156939709237045132856159368959981648969874765462190363842275826077556314448408825308218451
n = 24974121071274650888046048586598797033399902532613815354986756278905133499432183463847175542164798764762683121930786715931063152122056911933710481566265603626437742951648885379847799327315791800670175616973945640322985175516271373004547752061826574576722667907302681961850865961386200909397231865804894418194711076667760169256682834206788730947602211228930301853348503098156592000286467190760378847541148772869356389938999094673945092387627113807899212568399028514283219850734634544982646070106811651490010946670117927664594365986238107951837041859682547029079035013475238052160645871718246031144694712586073789250183
c = 10324627733161143472233272675096997859064721978612320424254305978486200326061730105384511258706433940176741256952824288120499229240005823611541292676234913505775165761543820764046537413943393325463602612485849366939102550336256797820440347815027443410399157963547486098366749815425187247171697678576246606105486928212486117878157055321965270364583625270716186820068538749425299073309429589410882809098930213978117176627031795312102177342499674234163614021182116065492884880492891668658240362567156235958605768725892407536211503981819707919444725863397622629226309480836486427388484176463279384813974310500625102568341
n = 14215826065753265334521416948225868542990756976323308408298887797364519400310818641526401662106853573185085731682502059761982246604277475488691297554851873224516934619888327644352138127883043558424300092247604877819821625587944308487310522092440517150600171819145803937177931473336108429889165189521078678397694303305705260759351843006130968234071638035667854938070597400634242396852782331461576526836227336952718230741560369621645218729592233657856104560425642219241082727756696967324334634822771842625681505869025740662258929200756109704988223034840699133778958569054445520305361142302393767439478256174414187983763
c = 415916446053083522663299405080903121619846594209033663622616979372099135281363175464579440520262612010099820951944229484417996994283898028928384268216113118778734726335389504987546718739928112684600918108591759061734340607527889972020273454098314620790710425294297542021830654957828983606433731988998097351888879368160881316237557097381718444193741788664735559392675419489952796677690968481917700683813252460912749931286739585465657312416977086336732056497161860235343155953578618273940135486362350057858779130960380833359506761436212727289297656191243565734621757889931250689354508999144817518599291078968866323093
n = 12221355905532691305226996552124162033756814028292708728711809229588190407700199452617060657420166395065565154239801465361510672853972152857415394695376825120759202857555325904640144375262531345320714166285999668052224661520834318497234299585219832943519644095197479639328120838919035625832361810964127485907587199925564724081163804724975965691571850962714258888527902920462746795712011579424322515292865504642938090200503979483095345893697972170153990274670257331483858538617460680462369680572833191232126527727222302641204529110948993583190295067970240051042000918629138767209918572311469915774910003970381965123241
c = 2248834602646305164283014556051672824689884721514190813323189875541899566338153534858709617544459297836048770439230174669883719627734394673012731609952869246171300132019334542245094425654362711870373095782083791160029789553806741967408922001051006100049326921742208757147339981269528740944842177729701945606827918253016001436218891580980192743564642120923356793292885805519110411357830040053435569937296612987581482128241218218550319154933831743819546558930918761162723110000328532730751591375727881221199739397698390594797621758011191224528339478784930214820615602510460640307707682865125229937141010351138099874025
n = 18152103454920389919231636321286527841833809319334215885641536161086810144890443857211776387914779781628740172079478910188540146498426564211851629962338413488555121865779016981727229209606498886170396500155102635962395243364899026418106378234307821492609778555173516000309435730752571818439328803899462791834490025768785383592935046996428331508608555503567191807692523852530836008436655164751054189301721070209363416058642811329040202582026786024825518381761299547703962502636888833428457116986351812252188468878701301184044948733274488264320930936362549028124581962244201377136969591119942276742760215403738913067567
c = 2797812094994121597295362327809389195134238119144547570610194659000554967367804835006774413888965325870488368112707535584687083342412367127561646136089638402907513075405746055834487062923240856950047936297155455745928810738711368950139327254040579266046642851362228893522740216519732851152162928545416236075387903789535000820423985522550638100049857678600662008021574841083416323980817348573062083159710189689337626277009675683473560325178417766400002763719953723259300977655801234386662217462862844994462505601804422871991694828697337752697234180117437785537788728412520613916334045368736691714704501962513954509705
n = 22877887459293720334652698748191453972019668578065068224653972884599636421200068659750242304040301306798039254241668648594556654589309801728248683586229288074709849246660525799452637187132633064172425677552176203292787732404537215347782229753837476655088638984496409603054524994383358547132112778403912563916886533181616856401929346567686400616307916690806467019665390260267596320840786982457521423178851498130935577260638269429250197050326097193841333205073650802709022947551398142692735680419453533128176592587955634333425401930362881423044363132586170013458300714163531162544301477356808388416864173949089028317961
c = 12271947322974809255127222556723394446467844330408506340843897575503534175121932185624776713618037572593449207329510171212097269297133492090526270770286000839978630002819714376964416081198925899119135271459404333829811516667576167576916805217016117373027245648473458331936273975110163065432285322832123169216976420362833557809289561705091817949915218278430834098156335989014645979633658818904753942786129126233956314517292746008579152368541316795082120147520597254020266752859205131887527661767589367756335766220841483940854397440079467053684289006956034944336788288196391829411432383541473132962783883758561108297747
n = 19844333358004073542783728196775487079202832688982038135532362073659058674903791697765527614270399097276261983744620537925712167578187109058145015032736796457938148615396547198728652435169126585595701228287449135664667959433491335769206692390262797325133960778920452511673878233190120432257482339068405290918739453464061987163074129048150451046315248186376609350095502130018696275764450248681787926130463463923862832714969425813770847493135627599129546112143050369344208092649256659330284904392961574494907186727388685504929586018639846040474616307662546605623294842316524163106100888851228858194942825157286544846177
c = 9531264751315473345056673937611382755236533664089452852716992791452558274873158812669513178040971923528201631609089069182049526587423864397527252061341857426422965190913745048414029690931254119437249218321954899956104589066479231204536856131403590472063496956452030342299863907499976917750846369802185896519725837163530049157920978007252920334447236842959033879772444475877613295594785710745889554296655932909212643500877218304116451889820444820534937901427158918411546484157737612926382420354101675658160847653151539420222526999426483473829341628599881460824765758346670633385844187252696874025582747177333702736465
n = 16956880944655068255446705024149899655327230949463546092744762226005904114738078692036960935391303255804754787864713189658290361949509917704853428701870609882427423574672772606814823959758208695540116440342488334213300943604780971422918744381486937517952553797134323570131582724393100092308466968491068503301604506186521656059375518680612292667310641047190088814753025794048591445267711939066523165042651430468971452726568222388482323097260496415484997546126185688914792795834046855221759289007609518312601640548469651358391745947588643697900883634533872314566389446271647587564348026861264979727062157272541149018781
c = 16110326928338602237561005337578085623028116490564329920738844771341250444164294693848130674347672763073995755532723894042946521372321947507527854966013459795492930736187058535665041545095683801386814190612817128504426590828954205050425979880047802547011117626354405687170961272200066258220699329112978151044633994329352673342582175349200008181837211288847301836681860817044391028992501763375849046751094019224570802498414368189170656992427042010362385494565216988561215657424755648213390551881450141899860811844684546992754530755092358644968088017107313907435586729574798046187046145596726569637758312033849476689378
n = 16472195897077185060734002588086375750797253422014472876266294484788862733424113898147596402056889527985731623940969291811284437034420929030659419753779530635563455664549165618528767491631867637613948406196511848103083967995689432928779805192695209899686072900265108597626632371718430059561807147486376536203800038054012500244392964187780217667805308512187849789773573138494622201856638931435423778275004491853486855300574479177472267767506041000072575623287557610576406578525902565241580838652860552046216587141709709405062150243990097835181557208274750462554811004137033087430556692966525170882625891516050207318491
c = 11867731823522211833301190385669833752050387304375114576570892885641949969365352586215693183003550684262313893105989683214739695968039039944442567581277252581988489020834299896625977474857889570528169919064941042132119301236852358823696947330423679033138054012027878783478922023431469564210485180679933264749281963405243082505688901662659030897104957499953192201440290084373968716271056483463909282407034181891901928790601973222643210525000717355062752079302291729448234374709852429885984987094307177760741403086538949190424454337896501402430653783597070178968921411867485584517214777073301007918941216316241784521708
n = 13890749889361612188368868998653029697326614782260719535555306236512452110708495623964530174188871342332417484996749651846510646453983388637377706674890018646246874688969342600780781646175634455109757266442675502522791531161284420286435654971819525519296719668701529481662071464145515727217108362496784024871976015116522898184301395037566514980846499856316532479656908169681719288258287756566886281183699239684997698487409138330229321935477734921670373632304542254938831218652340699024011371979519574576890581492623709896310465567043899767342676912434857372520308852745792360420376574037705943820090308501053778144141
c = 6250115196713939477947942995075509357173312813431601073354390451609559579925704891503987992181988654989477525811826607070378476102616752398280691012244301950194800995432882828020405062344160270290542566163969692748126314259624623341922057435728127596172871894887055305291345372720594481096374310285437492746765510292863238933163142677773310305789984897974266961231555124787205980411992251387207335655129551950825339766848166539671565212408741432649813058363660321480995187545006718837863674527475323414266732366507905974800565463011676462244368010182725161416783875646259625352308599198614681446394427674340328493047
n = 21457499145521259498911107987303777576783467581104197687610588208126845121702391694574491025398113729462454256070437978257494064504146718372095872819969887408622112906108590961892923178192792218161103488204912792358327748493857104191029765218471874759376809136402361582721860433355338373725980783308091544879562698835405262108188595630215081260699112737457564998798692048522706388318528370551365364702529068656665853097899157141017378975007689790000067275142731212069030175682911154288533716549782283859340452266837760560153014200605378914071410125895494331253564598702942990036163269043699029806343766286247742865671
c = 6269656777204332618433779865483197625538144405832409880710764183039800286008967127279281167109250083159801218370191973055663058165456565194979210256278526713608759141588082614531352489547674696723140599892318118960648862531538435596775798128845789504910467783731144808685373807716609662688064728614003904579841055786083326311313295311152563668422289435606771091246147867715987583149743032723028324394173498623642539175178996531881058274717907066845565199058931743481410454382746158558886667761300257488769795092777021292335562818583719708133179974425584610403335487082478848975656282384575767178925517257692365828720
'''             
```

在本题中，对明文flag使用了10组不同的公钥$<e, d>$进行加密。攻击思路与共模攻击有点相似。

简单陈述一下解决本题的思想：

当$RSA$被广泛使用时，每个人都可以使用它生成一对公钥与私钥。
但是我们知道一定范围内的素数分布是稀疏的(素数基本定理)。这意味着对$RSA$的滥用可能会导致如下情形出现：原本$N_1$和$N_2$都是利用数域分解法都无法有效分解的模数，但是利用多项式时间复杂度的$GCD$算法，你发现如下惊人的事实:
$$gcd(N_1, N_2) \neq 1$$
我们可以据此轻易地分解掉$N_1, N_2$ 。

具体详见这篇博客[https://sbseminar.wordpress.com/2012/02/16/the-recent-difficulties-with-rsa/]

攻击代码如下

```python
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from itertools import combinations

n1 = 17524722204224696445172535263975543817720644608816706978363749891469511686943372362091928951563219068859089058278944528021615923888948698587206920445508493551162845371086030869059282352535451058203615402089133135136481314666971507135484450966505425514285114192275051972496161810571035753943880190780759479521486741046704043699838021850105638224212696697865987677760179564370167062037563913329993433080123575434871852732981112883423565015771421868680113407260917902892944119552200927337996135278491046562185003012971570532979090484837684759828977460570826320870379601193678304983534424368152743368343335213808684523217
c1 = 6870605439714128574950893771863182370595667973241984289208050776870220326525943524507319708560433091378319367164606150977103661770065561661544375425887970907060665421562712515902428061727268441585629591525591001533188276465911918724808701356962871139957343861919730086334623932624184172272488406793955068827527130338853980609365042071290967556159598511667974987218999253443575482949258292953639729393456515185185102248985930422080581185292420347510600574229080211050520146551505605537486989306457793451086767402197128573781597156939709237045132856159368959981648969874765462190363842275826077556314448408825308218451
n2 = 24974121071274650888046048586598797033399902532613815354986756278905133499432183463847175542164798764762683121930786715931063152122056911933710481566265603626437742951648885379847799327315791800670175616973945640322985175516271373004547752061826574576722667907302681961850865961386200909397231865804894418194711076667760169256682834206788730947602211228930301853348503098156592000286467190760378847541148772869356389938999094673945092387627113807899212568399028514283219850734634544982646070106811651490010946670117927664594365986238107951837041859682547029079035013475238052160645871718246031144694712586073789250183
c2 = 1032462773316114347223327267509699785906472,1978612320424254305978486200326061730105384511258706433940176741256952824288120499229240005823611541292676234913505775165761543820764046537413943393325463602612485849366939102550336256797820440347815027443410399157963547486098366749815425187247171697678576246606105486928212486117878157055321965270364583625270716186820068538749425299073309429589410882809098930213978117176627031795312102177342499674234163614021182116065492884880492891668658240362567156235958605768725892407536211503981819707919444725863397622629226309480836486427388484176463279384813974310500625102568341
n3 = 14215826065753265334521416948225868542990756976323308408298887797364519400310818641526401662106853573185085731682502059761982246604277475488691297554851873224516934619888327644352138127883043558424300092247604877819821625587944308487310522092440517150600171819145803937177931473336108429889165189521078678397694303305705260759351843006130968234071638035667854938070597400634242396852782331461576526836227336952718230741560369621645218729592233657856104560425642219241082727756696967324334634822771842625681505869025740662258929200756109704988223034840699133778958569054445520305361142302393767439478256174414187983763
c3 = 415916446053083522663299405080903121619846594209033663622616979372099135281363175464579440520262612010099820951944229484417996994283898028928384268216113118778734726335389504987546718739928112684600918108591759061734340607527889972020273454098314620790710425294297542021830654957828983606433731988998097351888879368160881316237557097381718444193741788664735559392675419489952796677690968481917700683813252460912749931286739585465657312416977086336732056497161860235343155953578618273940135486362350057858779130960380833359506761436212727289297656191243565734621757889931250689354508999144817518599291078968866323093
n4 = 12221355905532691305226996552124162033756814028292708728711809229588190407700199452617060657420166395065565154239801465361510672853972152857415394695376825120759202857555325904640144375262531345320714166285999668052224661520834318497234299585219832943519644095197479639328120838919035625832361810964127485907587199925564724081163804724975965691571850962714258888527902920462746795712011579424322515292865504642938090200503979483095345893697972170153990274670257331483858538617460680462369680572833191232126527727222302641204529110948993583190295067970240051042000918629138767209918572311469915774910003970381965123241
c4 = 2248834602646305164283014556051672824689884721514190813323189875541899566338153534858709617544459297836048770439230174669883719627734394673012731609952869246171300132019334542245094425654362711870373095782083791160029789553806741967408922001051006100049326921742208757147339981269528740944842177729701945606827918253016001436218891580980192743564642120923356793292885805519110411357830040053435569937296612987581482128241218218550319154933831743819546558930918761162723110000328532730751591375727881221199739397698390594797621758011191224528339478784930214820615602510460640307707682865125229937141010351138099874025
n5 = 18152103454920389919231636321286527841833809319334215885641536161086810144890443857211776387914779781628740172079478910188540146498426564211851629962338413488555121865779016981727229209606498886170396500155102635962395243364899026418106378234307821492609778555173516000309435730752571818439328803899462791834490025768785383592935046996428331508608555503567191807692523852530836008436655164751054189301721070209363416058642811329040202582026786024825518381761299547703962502636888833428457116986351812252188468878701301184044948733274488264320930936362549028124581962244201377136969591119942276742760215403738913067567
c5 = 2797812094994121597295362327809389195134238119144547570610194659000554967367804835006774413888965325870488368112707535584687083342412367127561646136089638402907513075405746055834487062923240856950047936297155455745928810738711368950139327254040579266046642851362228893522740216519732851152162928545416236075387903789535000820423985522550638100049857678600662008021574841083416323980817348573062083159710189689337626277009675683473560325178417766400002763719953723259300977655801234386662217462862844994462505601804422871991694828697337752697234180117437785537788728412520613916334045368736691714704501962513954509705
n6 = 22877887459293720334652698748191453972019668578065068224653972884599636421200068659750242304040301306798039254241668648594556654589309801728248683586229288074709849246660525799452637187132633064172425677552176203292787732404537215347782229753837476655088638984496409603054524994383358547132112778403912563916886533181616856401929346567686400616307916690806467019665390260267596320840786982457521423178851498130935577260638269429250197050326097193841333205073650802709022947551398142692735680419453533128176592587955634333425401930362881423044363132586170013458300714163531162544301477356808388416864173949089028317961
c6 = 12271947322974809255127222556723394446467844330408506340843897575503534175121932185624776713618037572593449207329510171212097269297133492090526270770286000839978630002819714376964416081198925899119135271459404333829811516667576167576916805217016117373027245648473458331936273975110163065432285322832123169216976420362833557809289561705091817949915218278430834098156335989014645979633658818904753942786129126233956314517292746008579152368541316795082120147520597254020266752859205131887527661767589367756335766220841483940854397440079467053684289006956034944336788288196391829411432383541473132962783883758561108297747
n7 = 19844333358004073542783728196775487079202832688982038135532362073659058674903791697765527614270399097276261983744620537925712167578187109058145015032736796457938148615396547198728652435169126585595701228287449135664667959433491335769206692390262797325133960778920452511673878233190120432257482339068405290918739453464061987163074129048150451046315248186376609350095502130018696275764450248681787926130463463923862832714969425813770847493135627599129546112143050369344208092649256659330284904392961574494907186727388685504929586018639846040474616307662546605623294842316524163106100888851228858194942825157286544846177
c7 = 9531264751315473345056673937611382755236533664089452852716992791452558274873158812669513178040971923528201631609089069182049526587423864397527252061341857426422965190913745048414029690931254119437249218321954899956104589066479231204536856131403590472063496956452030342299863907499976917750846369802185896519725837163530049157920978007252920334447236842959033879772444475877613295594785710745889554296655932909212643500877218304116451889820444820534937901427158918411546484157737612926382420354101675658160847653151539420222526999426483473829341628599881460824765758346670633385844187252696874025582747177333702736465
n8 = 16956880944655068255446705024149899655327230949463546092744762226005904114738078692036960935391303255804754787864713189658290361949509917704853428701870609882427423574672772606814823959758208695540116440342488334213300943604780971422918744381486937517952553797134323570131582724393100092308466968491068503301604506186521656059375518680612292667310641047190088814753025794048591445267711939066523165042651430468971452726568222388482323097260496415484997546126185688914792795834046855221759289007609518312601640548469651358391745947588643697900883634533872314566389446271647587564348026861264979727062157272541149018781
c8 = 16110326928338602237561005337578085623028116490564329920738844771341250444164294693848130674347672763073995755532723894042946521372321947507527854966013459795492930736187058535665041545095683801386814190612817128504426590828954205050425979880047802547011117626354405687170961272200066258220699329112978151044633994329352673342582175349200008181837211288847301836681860817044391028992501763375849046751094019224570802498414368189170656992427042010362385494565216988561215657424755648213390551881450141899860811844684546992754530755092358644968088017107313907435586729574798046187046145596726569637758312033849476689378
n9 = 16472195897077185060734002588086375750797253422014472876266294484788862733424113898147596402056889527985731623940969291811284437034420929030659419753779530635563455664549165618528767491631867637613948406196511848103083967995689432928779805192695209899686072900265108597626632371718430059561807147486376536203800038054012500244392964187780217667805308512187849789773573138494622201856638931435423778275004491853486855300574479177472267767506041000072575623287557610576406578525902565241580838652860552046216587141709709405062150243990097835181557208274750462554811004137033087430556692966525170882625891516050207318491
c9 = 11867731823522211833301190385669833752050387304375114576570892885641949969365352586215693183003550684262313893105989683214739695968039039944442567581277252581988489020834299896625977474857889570528169919064941042132119301236852358823696947330423679033138054012027878783478922023431469564210485180679933264749281963405243082505688901662659030897104957499953192201440290084373968716271056483463909282407034181891901928790601973222643210525000717355062752079302291729448234374709852429885984987094307177760741403086538949190424454337896501402430653783597070178968921411867485584517214777073301007918941216316241784521708
n10 = 13890749889361612188368868998653029697326614782260719535555306236512452110708495623964530174188871342332417484996749651846510646453983388637377706674890018646246874688969342600780781646175634455109757266442675502522791531161284420286435654971819525519296719668701529481662071464145515727217108362496784024871976015116522898184301395037566514980846499856316532479656908169681719288258287756566886281183699239684997698487409138330229321935477734921670373632304542254938831218652340699024011371979519574576890581492623709896310465567043899767342676912434857372520308852745792360420376574037705943820090308501053778144141
c10 = 6250115196713939477947942995075509357173312813431601073354390451609559579925704891503987992181988654989477525811826607070378476102616752398280691012244301950194800995432882828020405062344160270290542566163969692748126314259624623341922057435728127596172871894887055305291345372720594481096374310285437492746765510292863238933163142677773310305789984897974266961231555124787205980411992251387207335655129551950825339766848166539671565212408741432649813058363660321480995187545006718837863674527475323414266732366507905974800565463011676462244368010182725161416783875646259625352308599198614681446394427674340328493047
n11 = 21457499145521259498911107987303777576783467581104197687610588208126845121702391694574491025398113729462454256070437978257494064504146718372095872819969887408622112906108590961892923178192792218161103488204912792358327748493857104191029765218471874759376809136402361582721860433355338373725980783308091544879562698835405262108188595630215081260699112737457564998798692048522706388318528370551365364702529068656665853097899157141017378975007689790000067275142731212069030175682911154288533716549782283859340452266837760560153014200605378914071410125895494331253564598702942990036163269043699029806343766286247742865671
c11 = 6269656777204332618433779865483197625538144405832409880710764183039800286008967127279281167109250083159801218370191973055663058165456565194979210256278526713608759141588082614531352489547674696723140599892318118960648862531538435596775798128845789504910467783731144808685373807716609662688064728614003904579841055786083326311313295311152563668422289435606771091246147867715987583149743032723028324394173498623642539175178996531881058274717907066845565199058931743481410454382746158558886667761300257488769795092777021292335562818583719708133179974425584610403335487082478848975656282384575767178925517257692365828720

public_keys = [n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11]
ciphertexts = [c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11]
public_exponents = [65537,65537,65537,65537,65537,65537,65537,65537,65537,65537,65537]


public_keys_combinations = list(combinations(public_keys, 2))
ciphertexts_combinations = list(combinations(ciphertexts, 2))
public_exponents_combinations = list(combinations(public_exponents, 2))


for i in range(len(public_keys_combinations)):
    n1, n2 = public_keys_combinations[i]
    if GCD(n1, n2) > 1:
        p  = GCD(n1, n2)
        q1 = n1 // p
        q2 = n2 // p
        phi1 = n1 - (p + q1) + 1
        phi2 = n2 - (p + q2) + 1
        
        c1, c2 = ciphertexts_combinations[i]
        e1 , e2 = public_exponents_combinations[i]
        d1 = inverse(e1, phi1)
        d2 = inverse(e2, phi2)
        
        m1 = pow(c1, d1, n1)
        m2 = pow(c2, d2, n2)
        print(long_to_bytes(m1))
        print(long_to_bytes(m2))
```

flag为moectf{it_is_re@lly_@_signin_level_cryPto_ch@ll@nge_ng92WPIBung92WPIBun}

emm,还是挺简单的

## xorrrrrrrrr

考察异或和`many time pad`,但是很显然`article`的信息被隐去了。

我们可以利用异或的性质以及flag格式的特点(以`b'moectf{`'开头),从多组密文中获得`article`的一部分信息，即得到一些零碎的英语单词。
最开始我首先试图拼接这些单词，试图获得足够长的article片段来异或得到`flag`，但是发现走不通，又尝试从得到的碎片"rs, You will learn how to "去直接搜索`article`,同样无果，只好再用一次异或，得到足够长的`flag`片段，再次异或一下密文组，得到充足长度的`article`片段，拼接后，Google一下，发现是CSAPP的序言内容，我们直接摘取足够长的一句话，异或回去，便得到了`flag`.

本题讲究的就是一个反复异或。

解题脚本如下：

```python
flag1 = b'moectf{'
L1 = len(flag1)
print(L1)
   
B1 = b'\x00\x00\x00\x00\x00\x01\x00'
C1 = b'\x00\n\x17\x10T\x11\x138\x10 >'
K = []# 密文集合
C = []

for i in range(100):
    C.append(K[i][:7])

strxor = lambda x,y: bytes([a^b for a, b in zip(x, y)])

M = []

for i in range(100):
    M.append(strxor(flag1, C[i]))
        
# print(M)        
M = [b'mers wh', b'ractica', b'flow vu', b'citing ', b'are com', b'rs. You', b'ar hard', b'hat pla', b'nd soft', b' correc', b'llocati', b'cessors', b'ss and ', b'and eve', b'er prog', b' and pe', b'g journ', b'rrectne', b'o get b', b'will le', b'rrors c', b' how to', b'learn p', b'e, and ', b'g of th', b'our own', b' averag', b'is know', b'ms. Spe', b'and Int', b' yourse', b'pts do ', b' Intern', b'ams. Sp', b'ndersta', b'ical er', b'll lear', b'rver. Y', b' during', b'arn how', b'falls o', b'ncepts ', b'earning', b'or prog', b'systems', b'ver tim', b'ocedure', b'ilar ha', b's and h', b'You wil', b'ou will', b'ompiler', b'arn how', b'. You w', b' affect', b'ms. You', b'r progr', b'm simil', b'fer ove', b' gether', b'ng to l', b'und the', b's. This', b' progra', b'u dedic', b'ou will', b'verage ', b'ether t', b'rning t', b'ies tha', b'un appl', b'lar fun', b'way tha', b'y error', b' and so', b'd the a', b'program', b'en your', b'ether t', b'ound th', b'concept', b' confou', b'ments p', b' during', b'he way ', b'nderlyi', b'nternet', b'omputer', b'nix she', b'learn h', b'learn h', b' and ev', b'piler i', b'\xe2\x80\x9d enl', b'n for p', b'owledge', b'k to ge', b'e your ', b' You wi', b' and me']
print(len(K[0]))

for i in K:
    if b'moectf{' in strxor(b'You will learn how the compiler implements procedure calls and how to use this knowledge', i):
        print(strxor(b'You will learn how the compiler implements procedure calls and how to use this knowledge', i))

# len(flag) = 72
```

flag为moectf{W0W_y0U_HaVe_mastered_tHe_x0r_0Peart0r!_0iYlJf!M3rux9G9Vf!JoxiMl}

## ez_chain

本题的突破点比较隐藏，考察`bytes_to_long()`的一点特性。

因为flag的长度与格式是固定的，而密钥则是通过对`bytes_to_long(flag)`进行一系列模运算得到的。从理论上说，我们只需利用flag的这些已知信息，便可以求出key。

经过实验我们发现，flag1 = b'moectf{????????????????????????????????????????????????????????????????}',flag2 = b'moectf{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!}'得到的key的值是相同的。这验证了我们的猜想。

由此便得到了了密钥`key`。至于加密过程使用到的`CBC`模式，其解密过程比较简单，此处不再赘述。

```python
from Crypto.Util.number import *
# from secrets import flag


# m = bytes_to_long(flag)
base = bytes_to_long(b"koito")
iv = 3735927943
print(base)
flag = b'moectf{????????????????????????????????????????????????????????????????}'
flag1 = b'moectf{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!}'


print(bytes_to_long(flag))
print(bytes_to_long(flag1))
print(bytes_to_long(flag)//base**14)
print(bytes_to_long(flag1)//base**14)

def blockize(long):
    out = []
    while long > 0:
        out.append(long % base)
        long //= base
    return list(reversed(out))
# 试试爆破一下BLOCKS

# blocks = blockize(m)


def encrypt_block_cbc(blocks, iv, key):
    encrypted = [iv]
    for i in range(len(blocks)):
        encrypted.append(blocks[i] ^ encrypted[i] ^ key)
    return encrypted[1:]


# print(encrypt_block_cbc(blocks, iv, key))
Encrypted = [iv, 8490961288, 122685644196, 349851982069, 319462619019, 74697733110, 43107579733, 465430019828, 178715374673, 425695308534, 164022852989, 435966065649, 222907886694, 420391941825, 173833246025, 329708930734]
print(len(Encrypted))



B = []
a = 0
t = 0
B1 = 5329712293
key = B1^iv^Encrypted[1]
for j in range(15):
    a = (Encrypted[j]^Encrypted[j+1])^key
    B.append(a)
    t = B[0]
for k in range(14):
    t = t * base + B[k+1]
        
T = long_to_bytes(t)
if b'moectf{' in T:
    print(T)                                     
```

flag为moectf{thE_c6c_Is_not_so_hard_9ifxi9i!JGofMJ36D9cPMxroif6!M6oSMuliPPcA3}

## flag_exchange

题目源码如下

```python
from Crypto.Util.number import isPrime
from random import getrandbits

with open("flag.txt","rb") as fs:
    flag = fs.read().strip()

def diffie_hellman(p, flag):
    alice_privKey = getrandbits(1024)
    alice_pubKey = pow(7, alice_privKey, p)
    bob_privKey = getrandbits(1024)
    bob_pubKey = pow(7, bob_privKey, p)

    superkey = pow(bob_pubKey, alice_privKey, p)
    m = int.from_bytes(flag, 'big')
    return (m * superkey) % p, alice_pubKey, bob_pubKey


from typing import Callable

def chall(input:Callable[[str],None], print:Callable[[str],None]):
    p = int(input("P = "))
    if isPrime(p) and p.bit_length() >= 1024:# 要求
        c, alice_pubKey, bob_pubKey = diffie_hellman(p, flag)
        print("Alice's public key: {}".format(alice_pubKey))
        print("Bob's public key: {}".format(bob_pubKey))
        print("Ciphertext: {}".format(c))
    else:
        print("Invalid P")
```

## 分析

题目实现了一个简单的Diffie-Hellman密钥交换协议，即我们可以获得$g^{a}\bmod p,g^{b}\bmod p$的值，目标则是计算出$superkey = a*b \bmod p$。很显然本题考察的是循环群$\mathbb{Z}_{p}^{*}$上的离散对数问题。这里我们可以在素数$p$上动一点手脚。注意到素数$p$要求大小至少为$1024bits$， 我们可以构造一个光滑的素数$p$，然后使用Pohilg-Hellman算法或者`sagemath`内置函数discrete_log来计算离散对数。

注：这个函数已经集成了Pohilg-Hellman算法。构造光滑数时，因子不宜太大。

至于算法的原理，这里笔者就不再赘述了，具体细节可以去看看书。

解题脚本

```python
# sage脚本        
# Smooth Number!
# 构造一个1024bits大小的'p-1'Smooth number,然后使用PH算法大力破解！
p = 2050446265000552948792079248541986570794560388346670845037360320379574792744856498763181701382659864976718683844252858211123523214530581897113968018397826268834076569364339813627884756499465068203125112750486486807221544715872861263738186430034771887175398652172387692870928081940083735448965507812844169983643977
Alice_public_key=149456061740410563391096867484777009374557360394196708211013203549944427056797257271195148499299608434072940505348306244858281632183222717721801692380116387982972142897537062401276240818820132437552913360193980518248945142486778589755150280253824174619677864790932988651529939028893785683357730963690157555456878
Bob_public_key=934170929777542326770845386060097480108072079738932180949515419083377590088127904510508319622531279857042146315260032176102099158050842908163873561113980541393016997331058930349038549972036164518526010123781616172790712748170379283493191780947094984477425793233386172095902619872589729572887813842336470127517722
Ciphertext=1274937371763886350622869127350858984479615552852111493480936676747377355626232543990154213613801159024431288164298223876380297282812856632681498817456751570667520075859060135843854772313108771316367005782488713294022220777554456568993365454227152365569089353590296876478369452163832599300863255510983390468501055
a = 7
F = GF(p)
a = F(7)
X = F(Alice_public_key)
n = a.order()
# ecm.factor(n)
primes = [2^3,3,7,636277,677857,682777,735809,860059,903949,908441,954851, 1017139, 1032341, 1163131, 1190737, 1227157, 1341323, 1395671, 1463611, 1556201, 1569401, 1713749, 1930931, 2219563, 2476283, 2477281, 2590633, 2756587, 2833643, 3095713, 3281449, 3688063, 4008793, 4285993, 5443981, 5720053, 5822981, 6201869, 6892217, 7093841, 7319857, 8227237, 9381107, 9477463, 10078729, 10084297, 10764907, 12416167, 14095651, 14294663,14788051]
X = F(Alice_public_key)
Y = Bob_public_key
dlogs = []
for fac in primes:
    t = int(n//fac)
    dlog = discrete_log(X**t, a**t)
    dlogs += [dlog]
    print("factor:"+str(fac)+",Discrete Log:"+str(dlog))
nC = crt(dlogs,primes)    


B = F(Bob_public_key)
k = pow(B, nC, p)
Q = (Ciphertext*inverse(k, p))%p
# 2023.08.15
```

## giant_e

题目描述:你这个e，红豆泥呆胶布得丝噶？(

根据题目描述,我们可以猜测这个e肯定是有问题的,结合题目名称:`giant_e`,应该是考察$RSA$低解密指数攻击

具体的加密过程代码如下:

```python
from Crypto.Util.number import getPrime

with open("flag.txt","rb") as fs:
    flag = fs.read().strip()

p = getPrime(1024)
q = getPrime(1024)
n = p * q
e = 0x609778981bfbb26bb93398cb6d96984616a6ab08ade090c1c0d4fedb00f44f0552a1555efec5cc66e7960b61e94e80e7483b9f906a6c8155a91cdc3e4917fa5347c58a2bc85bb160fcf7fe98e3645cfea8458ea209e565e4eb72ee7cbb232331a862d8a84d91a0ff6d74aa3c779b2b129c3d8148b090c4193234764f2e5d9b2170a9b4859501d07c0601cdd18616a0ab2cf713a7c785fd06f27d68dff24446d884644e08f31bd37ecf48750e4324f959a8d37c5bef25e1580851646d57b3d4f525bc04c7ddafdf146539a84703df2161a0da7a368675f473065d2cb661907d990ba4a8451b15e054bfc4dd73e134f3bf7d8fa4716125d8e21f946d16b7b0fc43
m = int.from_bytes(flag,"big")
c = pow(m,e,n)

print(n) # 0xbaa70ba4c29eb1e6bb3458827540fce84d40e1c966db73c0a39e4f9f40e975c42e02971dab385be27bd2b0687e2476894845cc46e55d9747a5be5ca9d925931ca82b0489e39724ea814800eb3c0ea40d89ebe7fe377f8d3f431a68d209e7a149851c06a4e67db7c99fcfd9ec19496f29d59bb186feb44a36fe344f11d047b9435a1c47fa2f8ed72f59403ebb0e439738fd550a7684247ab7da64311690f461e6dce03bf2fcd55345948a3b537087f07cd680d7461d326690bf21e39dff30268cb33f86eeceff412cd63a38f7110805d337dcad25e6f7e3728b53ca722b695b0d9db37361b5b63213af50dd69ee8b3cf2085f845d7932c08b27bf638e98497239
print(c) # 0x45a9ce4297c8afee693d3cce2525d3399c5251061ddd2462513a57f0fd69bdc74b71b519d3a2c23209d74fcfbcb6b196b5943838c2441cb34496c96e0f9fc9f0f80a2f6d5b49f220cb3e78e36a4a66595aa2dbe3ff6e814d84f07cb5442e2d5d08d08aa9ccde0294b39bfde79a6c6dcd2329e9820744c4deb34a039da7933ddf00b0a0469afb89cba87490a39783a9b2f8f0274f646ca242e78a326dda886c213bc8d03ac1a9150de4ba08c5936c3fe924c8646652ef85aa7ac0103485f472413427a0e9d9a4d416b99e24861ca8499500c693d7a07360158ffffa543480758cafff2a09a9f6628f92767764fa026d48a9dd899838505ae16e38910697f9de14
```

经过简单的计算,我们发现$\frac{e}{n} = 0.5174946640834999\cdots$。

此时$d$相对比较小,一般我们可以采用`Wiener attack`或`Boneh and Durfee attack`来恢复$d$。

但我们在这里可以采用另外一种基于$Lattice$的解法:

首先我们有如下关系式：

$e*d - k*\phi(n) = 1 \quad \phi(n) = n - (p+q) + 1 \quad n = p*q$

综合得到：
$$
e*d - k*n = 1 + k*(p+q-1) = O(d*\sqrt n)
$$
那么我们考虑由如下矩阵的行向量生成的二维格:

$$
M =
\left[
\begin{matrix}
e & \sqrt N \\
N & 0  
\end{matrix}
\right]
$$
则在$d$较小的假设下，不难发现$(e*d - k*n, d*\sqrt n)$是该格中的一个短向量。应用格基规约算法，我们可以求出这个向量来，并从这个向量的坐标中恢复$d$。进而我们可以解密出flag。

具体的解密过程如下：

```python
from Crypto.Util.number import long_to_bytes
n =0xbaa70ba4c29eb1e6bb3458827540fce84d40e1c966db73c0a39e4f9f40e975c42e02971dab385be27bd2b0687e2476894845cc46e55d9747a5be5ca9d925931ca82b0489e39724ea814800eb3c0ea40d89ebe7fe377f8d3f431a68d209e7a149851c06a4e67db7c99fcfd9ec19496f29d59bb186feb44a36fe344f11d047b9435a1c47fa2f8ed72f59403ebb0e439738fd550a7684247ab7da64311690f461e6dce03bf2fcd55345948a3b537087f07cd680d7461d326690bf21e39dff30268cb33f86eeceff412cd63a38f7110805d337dcad25e6f7e3728b53ca722b695b0d9db37361b5b63213af50dd69ee8b3cf2085f845d7932c08b27bf638e98497239
e = 0x609778981bfbb26bb93398cb6d96984616a6ab08ade090c1c0d4fedb00f44f0552a1555efec5cc66e7960b61e94e80e7483b9f906a6c8155a91cdc3e4917fa5347c58a2bc85bb160fcf7fe98e3645cfea8458ea209e565e4eb72ee7cbb232331a862d8a84d91a0ff6d74aa3c779b2b129c3d8148b090c4193234764f2e5d9b2170a9b4859501d07c0601cdd18616a0ab2cf713a7c785fd06f27d68dff24446d884644e08f31bd37ecf48750e4324f959a8d37c5bef25e1580851646d57b3d4f525bc04c7ddafdf146539a84703df2161a0da7a368675f473065d2cb661907d990ba4a8451b15e054bfc4dd73e134f3bf7d8fa4716125d8e21f946d16b7b0fc43
c = 0x45a9ce4297c8afee693d3cce2525d3399c5251061ddd2462513a57f0fd69bdc74b71b519d3a2c23209d74fcfbcb6b196b5943838c2441cb34496c96e0f9fc9f0f80a2f6d5b49f220cb3e78e36a4a66595aa2dbe3ff6e814d84f07cb5442e2d5d08d08aa9ccde0294b39bfde79a6c6dcd2329e9820744c4deb34a039da7933ddf00b0a0469afb89cba87490a39783a9b2f8f0274f646ca242e78a326dda886c213bc8d03ac1a9150de4ba08c5936c3fe924c8646652ef85aa7ac0103485f472413427a0e9d9a4d416b99e24861ca8499500c693d7a07360158ffffa543480758cafff2a09a9f6628f92767764fa026d48a9dd899838505ae16e38910697f9de14

s = floor(sqrt(n))
M = Matrix([[e, s], [n, 0]])
Mred = M.LLL()
D = [abs(Mred[i, 1]) // s for i in [0,1]]

for d in D:
    t = randint(2, n - 2)
    tt = pow(t, e, n)
    if pow(tt, d, n) != t:
        continue
    flag = int(pow(c, d, n))
    flag = long_to_bytes(flag)
    print(f'FLAG: {flag.decode()}')
# d = 3097392643622218352399316318311869135973941769654509211658361099112137137633314707911232044757294497446182734042997125781418817288903920510448190305509423    
```

注：我们这里使用了$floor(sqrt(N))$来近似$\sqrt N$。

FLAG: moectf{too_larGe_exponent_is_not_a_iDea_too!_Bung92WPIBung92WPIBung9?WP}

## minipack

背包密码入门题，考察超递增序列。

题目源码

```python
import random

with open("flag.txt", "rb") as fs:
    flag = fs.read().strip()

assert len(flag) == 72
m = int.from_bytes(b"\xff" + flag + b"\xff", "big")


def long2bits(long):
    bits = []
    while long > 0:
        bits.append(long & 1)
        long >>= 1
    return list(reversed(bits))


def genkey(len):
    sum = 0
    out = []
    for i in range(len):
        delta = random.randint(1, 10000)
        x = sum + delta
        out.append(x)
        sum += x
    return out
# key!

key = genkey(74 * 8)

with open("key.txt", "w") as fs:
    fs.write(str(key))


def encrypt(m, keys):
    data = long2bits(m)
    assert len(data) == len(keys)
    return sum((k if (p == 1) else 1) for p, k in zip(data, keys))


with open("ciphertext.txt", "w") as fs:
    fs.write(str(encrypt(m, key)))
```

分析过程：

容易看到$genkey$生成的公钥序列$p_{i}$具有如下特点
$$\sum_{i=1}^{N} p_{i} < p_{N+1}$$
即$p_{n}$是一个超递增序列，那么对于这样的一个背包问题，我们只需要贪心求解即可完成解密。

解题脚本如下：

```python

from Crypto.Util.number import*

key = []# 公钥
ciphertext = 44096612931024003148407895164090667174657344536623354666642108463093659898867859567157728084018394988840266329206836985537987081415020571845239234014695335928717091578810470705259929                                                             
t = len(key)
print(t)
print(74*8)
x = []
for i in range(t):
    x.append(0)
    
for i in range(1, t+1):
    if ciphertext >= key[t-i]:
        x[i-1] = 1
        ciphertext = ciphertext - key[t-i]
    else:
        x[i-1] = 0    



y = 0
for i in range(1, t+1):
    y += x[i-1] * 2**(i-1)
print(y)

print(long_to_bytes(y))
```

flag为moectf{superiNcreasiNg_sequeNce_is_useful_tO_cONstruct_a_KNapsacK_MAxSM}

## bad_random

题目描述：你能猜出这个随机数生成器生成的下一个数吗？

来点伪随机数！

首先看看题目的源码：

```python
import random

with open("flag.txt", "r") as f:
    flag = f.read().strip()


class LCG:
    def set_params(self):
        self.m = random.randint(10000, 20000)
        self.a = random.randint(10000, 20000)
        self.c = random.randint(1, self.a-1)
        self.x = random.randint(0, self.m-1)

    def get_all_output(self):
        x0 = self.x
        s = set()
        while (t := self()) not in s:
            s.add(t)
        self.x = x0
        return s

    def __init__(self):
        self.set_params()
        while len(self.get_all_output()) < 10:
            self.set_params()

    def __call__(self):
        self.x = (self.a * self.x + self.c) % self.m
        return self.x

from typing import Callable

def chall(input:Callable[[str],None], print:Callable[[str],None]):
    from hashlib import md5
    from string import ascii_letters
    s = "".join(random.choices(ascii_letters, k=16))
    h = md5(s.encode()).hexdigest()
    print(f"<!> md5(XXXXXXXX+{s[8:]}) == {h}")
    i = input("Give me XXXXXXXX: ")
    if md5((i + s[8:]).encode()).hexdigest() != h:
        print("<!> ACCESS DENIED <!>")
        return
    inst = LCG()
    print("Let's play a simple game! If you can guess the right number, I will give your the flag! You have 10 tries")
    for tries in range(10):
        i = input(f"Give me a number, you have failed for {tries} times: ")
        if int(i) == (right := inst()):
            print(f"Congurations! You win the game! Your flag is here: {flag}")
        else:
            print(f"Oh, you are wrong! The right number is {right}")
```

主要考察线性同余生成器(LCG)

这里LCG的三个参数$a,c,m$都是未知的，但是我们可以利用7组连续输出来尝试将这些未知参数解出来。
具体的推导如下：

$x_{i+1} = a*x_{i} + c\bmod m$

$t_1 = x_{i+2} - x_{i+1} = a*(x_{i+1} - x_{i}) \bmod m$

$t_2 = x_{i+3} - x_{i+2} = a*(x_{i+2} - x_{i+1}) \bmod m$

$t_3 = x_{i+4} - x_{i+3} = a*(x_{i+3} - x_{i+2}) \bmod m$

$t_1*t_2\bmod m = a^2*(x_{i+3} - x_{i+2})(x_{i+1} - x_{i})\bmod m$

$t_2 ^ {2}\bmod m = a^{2} * a^{1}(x_{i+1}-x_{i})*a^{-1}(x_{i+3} - x_{i+2})\bmod m$

综上得到$t_2^{2} - t_1*t_3 = 0\bmod m$,即$t_1*t_3-t_2^{2} = k*m,\quad k \in \mathbb{Z}$

再计算出下一组的$t_1*t_3 - t_2^{2}$，尝试用计算最大公约数的办法来恢复出$m$。
接下来恢复$a,c$这两个参数的过程就比较简单了，此处略去。

这样我们就可以做到预测这个伪随机数发生器的输出了。

```python
from pwn import *
from hashlib import md5
from Crypto.Util.number import *
from string import ascii_letters
import random

HOST, PORT = '127.0.0.1', 33249
sh = remote('127.0.0.1', 33249)

table = string.ascii_letters

def proof_of_work(s, tsha):
    for i in table:
        for j in table:
            for k in table:
                for l in table:
                    proof = i + j + k + l + s
                    if(md5(proof.encode()).hexdigest() == tsha):
                        sh.sendline((i + j + k + l).encode())
                        return
                    
pres = sh.recvuntil(b'md5(XXXX+', drop = True)
s = sh.recvuntil(b') == ', drop = True).decode()
tsha = sh.recvuntil(b'\n', drop = True).decode()

proof_of_work(s, tsha)

S = []

for _ in range(8):
    guess = str(random.randint(0, 20000))
    sh.sendline(guess)
    clean = sh.recvuntil(b'is ', drop = True)
    response = sh.recvuntil(b'\n', drop= True)
    S.append(int(response))
    print(S)

T1 = S[1] - S[0]
T2 = S[3] - S[2]
T3 = S[5] - S[4]
T4 = S[7] - S[6]
A1 = T1*T3 - T2**2
A2 = T2*T4 - T3**2
m1 = GCD(A1, A2)
a = ((S[2] - S[1])*inverse((S[1] - S[0]), m1)) % m1
b = (S[1] - a*S[0]) % m1
assert ((a*S[6] + b) % m1) == S[7]
sh.sendline(str((a*S[7] + b) % m1))
sh.interactive()
```

运行一次不一定能得到结果，可以多跑几次。(大概五次左右)

## broken_hash

本题考察对称性。

分析过程可以参考去年MoeCTF的`writeup`

解题脚本如下

```python
from pwn import *
from hashlib import sha256,md5
from Crypto.Util.number import long_to_bytes
from base64 import b64decode, b64encode
import random
import functools


HOST, PORT = '127.0.0.1', xxxxx
sh=remote('127.0.0.1', xxxxx)

table = string.ascii_letters

def proof_of_work(s,tsha):
    for i in table:
        for j in table:
            for k in table:
                for l in table:
                    proof=i+j+k+l+s
                    if(md5(proof.encode()).hexdigest()==tsha):
                        sh.sendline((i+j+k+l).encode())
                        return

pres=sh.recvuntil(b'md5(XXXX+',drop=True)
s=sh.recvuntil(b') == ',drop=True).decode()
tsha=sh.recvuntil(b'\n',drop=True).decode()

proof_of_work(s,tsha)
pres=sh.recvuntil(b'this is a random bytes: ',drop=True)
msg=sh.recvuntil(b'\n',drop=True)
forge_msg = msg[16:32] + msg[:16] + msg[48:64] + msg[32:48] +msg[64:]
sh.sendline(forge_msg)
sh.interactive()
```

注：交互脚本有点小问题。

## Factorize_me

考察$RSA$中的解密指数$d$泄露问题。

这种问题非常严重，因为我们不仅可以直接解密密文，甚至可以根据$d,e,N$的值来做到有效分解$N$。

在本题中我们知道$\phi(N)$的值，与之等效。

当$N = pq$时，已知$d*e = 1 + k*\phi(N)$，而由欧拉定理知
$$a^{d*e - 1} = 1 \bmod N \quad gcd(a, p*q) = 1$$
注意到$d*e-1$为偶数，则我们可以将其表示为$2^{t}*g$的形式，其中$g$为奇数。
我们计算一下$a^{d*e-1}-1$,得到如下分解：
$$a^{d*e-1} - 1 = a^{2^{t}*g} - 1 = (a^{g} - 1)(a^{g} + 1)(a^{2*g}+1)\cdots (a^{2^{t-1}*g}+1)=0 \bmod N$$
因为$N=P*Q$,$P,Q$均为素数。故我们可以计算上述分解式中各项与$N$的最大公约数,如果发现$GCD(a^{2^{i}*g} - 1, N) \neq 1,N$,我们便有效分解掉了$N$。

但是需要注意的是这是一个概率算法，分解的成功与否取决于$a$的选取，根据实际求解的经验，笔者一般是选择用分解出来的因子逐个作为$a$,依次分解，这样的成功率比较高。

核心模块如下：

```python
P = [] 
for i in range(t):
    x = pow(g, k1 // 2**i, PI)
    y = gcd(x - 1, PI)
    if y > 1 and x > 1:
        p = gcd(x - 1, PI)
        P.append(p)
```

或者使用如下函数(从网上抄的)：

```python
from math import gcd
from math import isqrt
from random import randrange


def factorize_multi_prime(N, phi):
    """
    Recovers the prime factors from a modulus if Euler's totient is known.
    This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize.
    More information: Hinek M. J., Low M. K., Teske E., "On Some Attacks on Multi-prime RSA" (Section 3)
    :param N: the modulus
    :param phi: Euler's totient, the order of the multiplicative group modulo N
    :return: a tuple containing the prime factors
    """
    prime_factors = set()
    factors = [N]
    while len(factors) > 0:
        # Element to factorize.
        N = factors[0]

        w = randrange(2, N - 1)
        i = 1
        while phi % (2 ** i) == 0:
            sqrt_1 = pow(w, phi // (2 ** i), N)
            if sqrt_1 > 1 and sqrt_1 != N - 1:
                # We can remove the element to factorize now, because we have a factorization.
                factors = factors[1:]

                p = gcd(N, sqrt_1 + 1)
                q = N // p

                if is_prime(p):
                    prime_factors.add(p)
                elif p > 1:
                    factors.append(p)

                if is_prime(q):
                    prime_factors.add(q)
                elif q > 1:
                    factors.append(q)

                # Continue in the outer loop
                break

            i += 1

    return tuple(prime_factors)

```

将$N$分解之后的处理

```python
from Crypto.Util.number import *
from sympy import nextprime
from itertools import combinations

p1 = 7592439908930473591169395506464664967460880934907692099467559610659035874008829133810341129161864445676397227262130671224157308868678442281617413952593477
p2 = 10022455487144667211701100343824680124338467215246658405697280466931561838565228778624923751405642974058833143888323468902504576610147119708725877528011439
p3 = 6991223361118904775931217829045348785013077549030883418924453538830605687999480005714979700653172534877541317997174968789510984315425270755055110913347281
p4 = 7661276973316857207751367277881032536449069939447322837508906694964933673171693624171780997296797446643574508184011878230465391879808258241752897792891323
p5 = 11627877395179828773706504422918933052041685770731872812302758181943244472706231518350716590168708806854971155512042158777017234038219076771501368374236727
p6 = 6811480804433459752827714558479851837166061762294131563310130325846430072816177165149613687307165209577130630311477665591141650399740741396784593477667511
p7 = 9987009117206906203158749743824168660291275882852229158070368815160479543708376165641735042845357978292384303332559592302507789120810447986634662721490507
p8 = 8752762682421281693932454897190422008900505775990831144558827755415243453970083322530846132571648469860763497724505255094464743633789884168771246977571539
p9 = 12876877424944854147075816504195994138450356002779004886384584287813869165469217718717854027672044903401715370348223932937626725119320180795716270261309139

e = 65537
c = 841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140  
n = 899081756851564072995842371038848265712822308942406479625157544735473115850983700580364485532298999127834142923262920189902691972009898741820291331257478170998867183390650298055916005944577877856728843264502218692432679062445730259562784479410120575777748292393321588239071577384218317338474855507210816917917699500763270490789679076190405915250953860114858086078092945282693720016414837231157788381144668395364877545151382171251673050910143023561541226464220441

primes = [p1, p2, p3, p4, p5, p6, p7, p8, p9]
public_exponent = []

public_exponent = list(combinations(primes, 3))

m = 0
for i in range(len(public_exponent)):
    n1, n2, n3 = public_exponent[i]
    prod = nextprime(n1) * nextprime(n2)*nextprime(n3)
    phi = (nextprime(n1) - 1)*(nextprime(n2) - 1)*(nextprime(n3) - 1)
    if n == prod:
        d = inverse(e, phi)
        m = pow(c, d, prod)
        print(long_to_bytes(m))
        print(public_exponent[i])
        break


```

flag:moectf{you_KNow_how_to_faCtorize_N_right?_9?WPIBung6?WPIBung6?WPIBund6?

emm,还是挺简单的

注：复盘时突然发现在factordb上有人在8.18上传了$n$的分解结果(🤣)

## Feistel_promax

本题加密过程的代码具体如下：

```python
from Crypto.Util.number import *
from os import urandom

round = 2
flag = open("./secret", "rb").read().strip()


def f(m, key):
    m = m ^ (m >> 4)
    m = m ^ (m << 5)
    m = m ^ (m >> 8)
    m ^= key
    m = (m * 1145 + 14) % 2**64
    m = (m * 1919 + 810) % 2**64
    m = (m * key) % 2**64
    return m


def enc(m, key, round):
    key = bytes_to_long(key)
    left = bytes_to_long(m[:8])
    right = bytes_to_long(m[8:])
    for i in range(round):
        left, right = right, f(right, key) ^ left
    left, right = right, left
    return long_to_bytes(left).rjust(8, b"\x00") + long_to_bytes(right).rjust(8, b"\x00")


def padding(m):
    mlen = len(m)
    pad = 16 - mlen % 16
    return m + pad * bytes([pad])


def ecb_enc(m, key):
    m = padding(m)
    mlen = len(m)
    c = b""
    for i in range(mlen // 16):
        c += enc(m[i * 16 : i * 16 + 16], key, round)
    return c


key = urandom(8)

print(ecb_enc(padding(flag), key))
# b'B\xf5\xd8gy\x0f\xaf\xc7\xdf\xabn9\xbb\xd0\xe3\x1e0\x9eR\xa9\x1c\xb7\xad\xe5H\x8cC\x07\xd5w9Ms\x03\x06\xec\xb4\x8d\x80\xcb}\xa9\x8a\xcc\xd1W\x82[\xd3\xdc\xb4\x83P\xda5\xac\x9e\xb0)\x98R\x1c\xb3h'
```

审计完代码便会发现本题的加密过程所使用的函数与`feistel`中是完全相同的，但考察点已经不再是针对`feistel`网络的分析了。本题的考察核心在轮函数`f`。

我们的主要任务只有一个，那就是将key打出来。

首先我们注意到：

```python
print(ecb_enc(padding(flag), key))
```

这一步非常奇怪：为什么要在加密`flag`前先对其进行一步`padding`操作呢？

我们可以先做个实验。

```python
print(padding(padding(b'hello')))
# b'hello\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10'
```

发现进行如此操作后，加密函数所处理的明文即变成了如下形式：
$$flag + m + 16*long2bytes(16)$$

即明文的最后一个长度为16字节的块已知，同时我们可以根据$ECB$工作模式的特点：求出其对应的密文如下：

```python
L = cipher[48:56]
R = cipher[56:]
```

再根据feistel网络的特点，我们可以进一步得到$f(a, key)$和$f(f(a, key)\bigoplus a, key)$。
到这里我们需要一点理论知识的指导了。

此时我们的目标已经转换为了如下具体问题：

已知函数$f$的结构以及输入$a_0$和输出$f(a_0, key)$, 如何求解出`key`

根据出题人的提示：分组密码设计的核心原则是混淆与扩散，考察一下函数$f$是否很好地实现了混淆与扩散。

我们可以在本地另设一对$a,key$，尝试改变a的部分二进制位，发现一个奇妙的事情，输出$f(a, key)$的低位甚至保持不变。(具体的实验过程略去) 而扩散原则要求密码体制可以将明文的变化扩散到整个密文中去。显然，这个轮函数$f$的扩散能力是很弱的。

更近一步地，根据出题人的提示，模数$2^{64}$是不合适的。
经过试验和推导发现f这个函数如果将模数依次更改为$2^{48},2^{32},2^{16}$,同时key也取模相应的模数，得到的输出与原输出取相应的模后的值是完全相同的，我就想到了可以像针对ECB的`beast attack`那样，结合函数`bytes_to_long()`的特点，依次爆破key的部分(比如每次猜测两个字节)，用改变模数的f来检验是否为可能的候选值，最终拼凑出来可能的key,尝试解密，就拿到了`flag`。

`这个原理就是%2^64成立的式子，%2的任意小于64的幂次都成立, 所以高位不会影响低位, 所以可以逐位爆破`

解题脚本具体如下：

（写的比较烂，可以用`BFS`优化一下）

```python
from Crypto.Util.number import *

round = 2
ciphertext = b'B\xf5\xd8gy\x0f\xaf\xc7\xdf\xabn9\xbb\xd0\xe3\x1e0\x9eR\xa9\x1c\xb7\xad\xe5H\x8cC\x07\xd5w9Ms\x03\x06\xec\xb4\x8d\x80\xcb}\xa9\x8a\xcc\xd1W\x82[\xd3\xdc\xb4\x83P\xda5\xac\x9e\xb0)\x98R\x1c\xb3h'
# key = urandom(8)


def f(m, key, N):
    m = m ^ (m >> 4)
    m = m ^ (m << 5)
    m = m ^ (m >> 8)
    m ^= key
    m = (m * 1145 + 14) % N
    m = (m * 1919 + 810) % N
    m = (m * key) % N
    return m


def enc(m, key, round1):
    key = bytes_to_long(key)
    left = bytes_to_long(m[:8])
    right = bytes_to_long(m[8:])
    for i in range(round1):
        left, right = right, f(right, key, 2**64) ^ left
    left, right = right, left
    return long_to_bytes(left).rjust(8, b"\x00") + long_to_bytes(right).rjust(8, b"\x00")


def padding(m):
    m_len = len(m)
    pad = 16 - m_len % 16
    return m + pad * bytes([pad])


def ecb_enc(m, key1):
    m = padding(m)
    m_len = len(m)
    c = b""
    for i in range(m_len // 16):
        c += enc(m[i * 16: i * 16 + 16], key1, round)
    return c


def dec(m, key, round1):
    key = bytes_to_long(key)
    left = bytes_to_long(m[:8])
    right = bytes_to_long(m[8:])
    for i in range(round1):
        left, right = right, f(right, key, 2**64) ^ left
    left, right = right, left
    return long_to_bytes(left).rjust(8, b"\x00") + long_to_bytes(right).rjust(8, b"\x00")


L = ciphertext[48:56]
R = ciphertext[56:]
L0 = bytes_to_long(R)
R0 = bytes_to_long(L)
a = bytes_to_long(8*b'\x10')
f1 = L0 ^ a # f1 = f(a, key, 2**64)
f2 = R0 ^ a # f2 = f(f(a, key, 2**64)^a, key)
F = []
for i in range(4):
    F.append(f1 % 2**((i+1)*16))
        
for item1 in range(2**8, 2**16):
    key1 = item1
    if f(a, key1, 16) == int(F[0]):
        print(long_to_bytes(key1))

E1 = [b',\xb4', b'A"', b'\xac\xb4', b'\xc1"']
for i in E1:
    for item2 in range(2**8, 2**16):
        key2 = item2 * 2**16 + bytes_to_long(i)
        if f(a, key2, 32) == int(F[1]):
            print(long_to_bytes(key2))
            
E1 = [b'FD\xac\xb4',b'\xc6D\xac\xb4',b'w\xeb\xc1"',b'\xf7\xeb\xc1"']
for i in E1:
    for item3 in range(2**8, 2**16):
        key3 = item3 * 2**32 + bytes_to_long(i)
        if f(a, key3, 48) == int(F[2]):
            print(long_to_bytes(key3))
            
E1 = [b'*zFD\xac\xb4',b'\xaazFD\xac\xb4',b'\x0f\x00w\xeb\xc1"',b'\x8f\x00w\xeb\xc1"']                        
for i in E1:
    for item4 in range(2**8, 2**16):
        key4 = item4 * 2**48 + bytes_to_long(i)
        if f(a, key4, 64) == int(F[3]):
            print(long_to_bytes(key4))
            
E1 = [b'4t*zFD\xac\xb4',b'\xb4t*zFD\xac\xb4',b'\\q\x0f\x00w\xeb\xc1"',b'\xdcq\x0f\x00w\xeb\xc1"']            
print(len(E1[0]))


c = ciphertext
C = []
for i in range(len(c)//16):
    C.append(c[i * 16 : i * 16 + 16])
    
for key in E1:    
    a = dec(C[0], key, round)
    b = dec(C[1], key, round)        
    c = dec(C[2], key, round)
    d = dec(C[3], key, round)
    print(a+b+c+d)
```

flag为moectf{F_func_1s_n1t_Ve5y_$EcU%e}
